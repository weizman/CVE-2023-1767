
> _tl;dr - a stored XSS on `snyk.io` allowed me to fabricate the health score granted for packages in my control, which I leveraged into making it seem as my "malicious" package is infact healthy, popular and legitimate, which could have served an attacker to convince others to install an actual malicious npm package._ 

## What motivated me to write this?

On March of 2023 I found a stored XSS on `snyk.io`. 

As an experienced web vulnerability researcher, I dedicated some time into maximizing the impact that one can achieve with such power, in order to help Snyk defend themselves against any further potential damage they might be exposed to.

However, considering the fact that Snyk is a security services vendor, I was wondering if there's anything more interesting and creative to be done here than just compromise the application and/or its current logged in victim.

In this article I demonstrate how I can take such a narative and turn it against the business itself, and the very main purpose of the [Snyk Advisor service](https://snyk.io/advisor/).

> DISCLAIMER - This is mostly a thought experiment around a real no-longer-existing vulnerability, where in reality there might be other unrelated reasons (mostly humane) why my experiment wouldn't have actually worked (although my finding is potentially dangerous as it is). I admire Snyk's work and its team a lot, and highly recommend them as a service!

## Supply chain security - an intro

Supply chain security is something we constantly hear of in the past years, and for a good reason.

We build our softwares on top of a long chain of dependencies that we don't control and that change frequently,
so just trusting them to be legitimate in the long run is not something we can work with.

That's why in the past few years we see more and more attempts to produce products that attempt to secure against that problem specifically.

I myself have dedicated years of my career and spare time (and still am) into improving the worlds' chances against JavaScript supply chain attacks by being the initial creator of [PerimeterX](https://perimeterx.com/)'s [CodeDefender](https://www.humansecurity.com/products/code-defender), the solo creation and maintanance of [Snow ‚ùÑÔ∏è JS](https://github.com/lavamoat/snow/) and the ongoing effort around maintaining the highly advanced supply chain security tool [LavaMoat üåã](https://github.com/lavamoat/lavamoat/).

This situation naturally creates a clear motivation for attackers to infiltrate your supply chain.
There are a number of ways attackers can leverage your need for building your software on top of third party dependencies, here are two main ones:

### 1. Compromising an already-used legitimate package

One thing attackers tend to do is to find a third party package that is being used by the maintainer of the application they wish to attack, and then take control over it.
Clearly the chances to succeed in that are low, but once control is gained, the attacker can push a new version to that package, introducing the exploit they wish to bring across the application.

At this point, it's likely that the maintainer will eventually update their dependencies to their newer versions, thus potentially pulling the compromised version of the breached dependency without even being aware of that.

### 2. Luring to use a yet-to-be-used malicious package

Another thing attackers might do is to publish a new dependency they control and make it look like it does legitimate stuff, then try to lure developers into installing those in their projects. Once they do, the package which isn't actually legitimate, can compromise the software.

However, this requires some level of sophistication, because you have to convince the developer, a human being, that your package is legitimate and trustworthy - and that is a hard task considering the level of awareness developers have for the potential damage that lies in using a new and unfamiliar package.

Let's elaborate on that.

## Luring developers is hard!

Because of the growing concern that evolves around supply chain attacks, developers are more aware of the problem and make sure to be able to tell the difference between a legitimate package and a suspicious one.

So what actions do developers take when considering installing a new package?

Here's a perfect answer to the question by the amazing ChatGPT!

<img width="896" alt="225322358-5060c684-525c-4b32-908d-2c087e4a2f6f (1)" src="https://user-images.githubusercontent.com/13243797/225638237-722c9b4b-9cd5-4ef0-9d21-9077544d887a.png">

> _"(1) popularity and reputation"_

I'd say, this is where you start. A good way to get a general sense of the legitimacy of a package is by understanding how popular and well known it is. It's usually never enough to fully tell its legitimacy, but it does help knowing many people starred it, or even better, recently downloaded and used it.

> _"(2) dependencies, (3) source code and (4) maintainers"_

These are even better ways for telling if a package is trustworthy. Popularity for itself isn't enough, but if you can afford going through its dependencies and maintainers and make sure they're also popular and legit, it would help a lot in making the decision. If you can even afford browsing through its source code that's amazing! But that's unlikely to be something we're going to do.

> _"(5) license"_

I'm honestly not sure how's this related, but I had to give ChatGPT the credit for trying ü§∑ - although next one is the killer section I was hoping ChatGPT would say (I DID NOT TOUCH THIS - THIS WAS ALL CHATGPT!):

> _"(6) Use a package verification tool ... such as **Snyk**"_

This is the ultimate section that supposed to eliminate the need for all previous sections. 
As I said ealier, due to the concern of the industry, naturally we now have third party services to help us verify the integrity of third party packages instead of having to do the dirty job ourselves.

**These products are your one-stop-shop!**

They examine all packages and take into consideration everything mentioned above - such as popularity, usage, amount of recent downloads, integrity of contributers, level of community engagment and even potentially source code static analisys - and they calculate it all into a score, to give you a sense of how legitimate for use that package.

In other words, **they try to combine steps 1-4 into a single service, so you wouldn't have to go through them yourself.**

There are more such services than just [Snyk](https://snyk.io/advisor/), (e.g. [Socket Security](https://socket.dev/npm)), 
but Snyk is probably the most popular service among the others.

## A single point of failure

When thinking about, Snyk being a one-stop-shop could also be a bad thing, because if it fails it could also be a single point of failure.
In other words, Snyk providing all the information you need for deciding if to use a package or not means you can skip the due diligence you were planning to do yourself, and just trust their health score completely.

And if the integrity of the service is broken, you wouldn't count on a second service to help you discover that - because that's the whole point of the advisor service!

This of course counts on an ability to break the integrity of the service, which is not a trivial asumption at all. 

## Markdown XSS!

So let's first focus on breaking that integrity. 

At this point you should already be familiar with Markdown. It's this fun and easy format for writing simple documents, and it is highly used.
You're probably familiar with it being the standard format for writing README files - when you visit a Github repository or an npm package, they usually use a MarkDown file called `README.md` as the main file for presenting the project (e.g. `react` on [GitHub](https://github.com/facebook/react#readme) and [npm](https://www.npmjs.com/package/react))

The trick about Markdown however, is that it has popular extensions to it to enhance its power, such as [GLF](https://github.github.com/gfm/#introduction), and the popular ones accept HTML!

In fact, the parsers used by GitHub and npm also accept HTML. 
Therefore, since Markdown files containing HTML are considered valid, it became a standard that the rest of the industry keeps up with.

However, to [quote](https://github.github.com/gfm/#TOC:~:text=While%20GFM%20supports%20a%20wide%20range%20of%20inputs%2C%20it%E2%80%99s%20worth%20noting%20that%20GitHub.com%20and%20GitHub%20Enterprise%20perform%20additional%20post%2Dprocessing%20and%20sanitization%20after%20GFM%20is%20converted%20to%20HTML%20to%20ensure%20security%20and%20consistency%20of%20the%20website.) from the offical GLF document by github:

> "While GFM supports a wide range of inputs, it‚Äôs worth noting that **GitHub.com and GitHub Enterprise perform additional post-processing and sanitization after GFM is converted to HTML to ensure security** and consistency of the website."

In other words, the industry might be rather aligned when it comes to supporting HTML and other GLF extensions of Markdown - but there's a good chance they don't perform the extra sanitization required for keeping things safe!
